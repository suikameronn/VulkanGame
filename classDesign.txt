作りたいもの
まずは、テキストを読み込むと、モデル、テクスチャ、アニメーション、ギミック、ライトやそれらの初期座標などが読み込まれ、
それをステージを生成する。

ソフトの動作する流れ

タイトル画面が表示される

読み込みたいシーンを選択する

シーンを読み込む

モデルやライトなどのオブジェクトを生成して、ステージを作成する

キーボードなどでキャラクターを操作して、ゴールまで行く

ゴールについたらクリア画面を表示

再びステージ選択

以下それぞれのセクションで必要なものを書いていく

<タイトル画面が表示される>

2Dの描写

コントローラの入力を受け取る

保存されているシーンファイルの確認、読み込み

<シーンを読み込む>

シーンを読み込むためのパーサー、トークナイザー

<モデルやライトなどのオブジェクトを生成して、ステージを作成する>

これらの描写やメモリ管理など

<ゴールついたらクリア表示>

タイトル同様

<再びステージ選択>

特になし

////////////////////////////////////////////////////////////////////////////
<モデルやライトなどのオブジェクトを生成して、ステージを作成する>
////////////////////////////////////////////////////////////////////////////
この部分が肝なので、ここの実装について書いていく

モデルやテクスチャなどのファイルから読み取るものは、Storageクラス(未作成)にunordered_mapを使って、
モデルやテクスチャファイルの対応されたid(enumのOBJECT,IMAGEDATA)をkeyとして、
それぞれMeshesクラス、Imageクラスのインスタンスとして保存する。
モデルやテクスチャ画像のデータが欲しい際は、基本的にここから参照あるいは、コピーをする。
次に、Storageクラスに格納されるデータはあくまで、これから生成するオブジェクトの設計書のようなもので、
Animationなどの同一のモデルやテクスチャのモデルでもそれぞれのモデルで異なる場合があるものは、
Modelクラスとして、メッシュとテクスチャ(マテリアル)がセットになったものに保存する。
それぞれのModelクラスにアクセスするには、現在はそれぞれに設定された固有の名前でアクセスする。

例えば、球のモデルを100個画面に生成したい場合、球の種類のStorageクラスから頂点情報を読み取り、
球用のStorageクラスから画像情報を読み取り、それをもとにModelクラスを100個生成する。

ファイルから必要なモデルを読み込むのは、シーンファイルをパースするのと同時に行われ、
シーンファイルから指定されたモデルやテクスチャ画像がStorageクラスに存在する場合は、それを参照するようにして、
ない場合は、先ほどのように生成してStorageクラスに格納して、それへの参照を返す。

次に、シーンに必要なModelクラス(モデル、テクスチャ、Animationなどを組み合わせたもの)を保存するには、
それぞれのインスタンスにstringの文字列でアクセスするため、unordered_mapを用いて記録する。
std::unordered_map<std::string,std::shared_ptr<Model>>といった具合に格納する。
モデル、テクスチャ、Animationを格納する流れとしては、パーサーがオブジェクトの名前、仮初のシーンファイルscene.txtでいう
Cube(オブジェクトの名前)を読み取ったら、Modelクラスのインスタンスを作成して、それぞれのトークンを読みとったらset〜()で
セットしていく。

Modelクラスを必要なだけ、生成出来たら、このModelクラスを渡す。この際、VkModelクラスを生成して、
Vulkan側が欲しいデータ(オブジェクトの原点からの距離など)を渡すことで、Vulkan側にデータを渡す。
このVkModelクラスにはVulkan固有の機能である、Descriptorなどを示すidなどを持つ。

VkModelクラスを利用したレンダリングは後日記載する

レンダリングが終了したら、VkModelクラスはすべて破棄する。

次のフレームの処理に移す。最初のフレームはModelクラスを生成したのちに、すぐにレンダリングしたが、2フレーム目からは、
Sceneクラス内のUpdateFrame関数でModelクラスの処理(Animationによる座標移動など)を終わらせてからレンダリングする。

Animation関数に関する記述は後日。

このようにしてとりあえず、シーンのレンダリングをする。


<FileManagerクラス>

このクラスはインスタンスをstatic変数としてどこでもアクセスできるようにする
シングルトン(fileManagerクラスも同様)


<Storageクラス>
private:

Meshesのポインタを持つマップ

ImageDataのポインタを持つマップ

それぞれのマップにファイルから読み取ったデータの参照を加える関数

public:

マップの持つポインタの所有権を共有する関数

マップの持つポインタの生ポインタを返す関数

それぞれのマップのサイズを返す関数

<Modelクラス>
private:
Storageクラスの持つMeshesクラスのポインタ

Materialクラスのポインタ(インスタンスはModelクラスで生成)

public:

Meshesポインタをセットする関数

ImageDataポインタをセットする関数

Materialポインタをセットする関数

<Materialクラス>
private:
glm::vec3のdiffuseなどの変数を持つ

StorageクラスのImageDataへのポインタを持つ

コンストラクタ：引数として、MeshesとImageDataのポインタを持つ

マテリアルの係数を設定する関数:diffuseなど

マテリアルのテクスチャをセットする関数

マテリアルの係数をそれぞれ返す関数

マテリアルのテクスチャを返す関数

<Sceneクラス>
private:
stringをキーとしてModelクラスのunique_ptrを持つマップ

public:
コンストラクタ：vector<char>にファイルの文字列を入れる

vector<char>の文字列のパースをする関数、トークナイザーなどを利用する

VulkanBaseクラスのVkModelクラスにModelクラスをセットする関数
(Modelクラスがどういうつのテクスチャなどを参照している場合は、VulkanBaseクラス側で対応する
、なので、実際には、VulkanBaseクラス側のVkModelクラスを作成する関数にModelクラスを引き渡す関数)

このクラスはシングルトンを使用する
<VulkanBaseクラス>
private:
Vulkanの動作に必要な様々な変数

VkModelクラスのunique_ptrを持つvector配列

public:
VkModelクラスからデータを読み取り、レンダリングする関数

Modelクラスから呼び出され、VkModelクラスを作成する関数、Modelクラスのポインタを引数に持つ

<VkModelクラス>
private:

Descriptorの配列から使用するものを指定するIDとなるuint32_t

public

Meshesのポインタを返す関数

Materialのポインタを返す関数

Vulkanでのレンダリングに必要なもの

1.テクスチャを持たないモデルとテクスチャを持つモデルの二つを描く場合は、DescriptorLayoutが二つ必要。
テクスチャの種類の違いによって、レイアウトの数も応じる必要ない。

2.前述の場合、グラフィックスパイプラインが二つ必要。シェーダによってテクスチャ用のdescriptorを引数とするシェーダとそうでないシェーダの二つを利用するため。
この場合でもデプスバッファー関連は、RenderPassの管轄なので、深度テストは行われる。

3.DescriptorLayoutが異なる場合、その数だけのCommandPoolが必要

4.モデルのマテリアルなどの各種設定と、それに合わせた、DescriptorSetLayoutとDescriptorPoolを引数に渡して、DescriptorSetを作成する。
なお、これには、テクスチャの違う場合は、それに応じた個数を作らなければならない

5.描画時、まずグラフィックスパイプラインを設定して、頂点、インデックス、DescriptorSetsと指定して、最後に、vkCmdDrawIndexed()を実行する。