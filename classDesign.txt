作りたいもの
まずは、テキストを読み込むと、モデル、テクスチャ、アニメーション、ギミック、ライトやそれらの初期座標などが読み込まれ、
それをステージを生成する。

ソフトの動作する流れ

タイトル画面が表示される

読み込みたいシーンを選択する

シーンを読み込む

モデルやライトなどのオブジェクトを生成して、ステージを作成する

キーボードなどでキャラクターを操作して、ゴールまで行く

ゴールについたらクリア画面を表示

再びステージ選択

以下それぞれのセクションで必要なものを書いていく

<タイトル画面が表示される>

2Dの描写

コントローラの入力を受け取る

保存されているシーンファイルの確認、読み込み

<シーンを読み込む>

シーンを読み込むためのパーサー、トークナイザー

<モデルやライトなどのオブジェクトを生成して、ステージを作成する>

これらの描写やメモリ管理など

<ゴールついたらクリア表示>

タイトル同様

<再びステージ選択>

特になし

////////////////////////////////////////////////////////////////////////////
<モデルやライトなどのオブジェクトを生成して、ステージを作成する>
////////////////////////////////////////////////////////////////////////////
この部分が肝なので、ここの実装について書いていく

モデルやテクスチャなどのファイルから読み取るものは、Storageクラス(未作成)にunordered_mapを使って、
モデルやテクスチャファイルの対応されたid(enumのOBJECT,IMAGEDATA)をkeyとして、
それぞれMeshesクラス、Imageクラスのインスタンスとして保存する。
モデルやテクスチャ画像のデータが欲しい際は、基本的にここから参照あるいは、コピーをする。
次に、Storageクラスに格納されるデータはあくまで、これから生成するオブジェクトの設計書のようなもので、
Animationなどの同一のモデルやテクスチャのモデルでもそれぞれのモデルで異なる場合があるものは、
Modelクラスとして、メッシュとテクスチャ(マテリアル)がセットになったものに保存する。
それぞれのModelクラスにアクセスするには、現在はそれぞれに設定された固有の名前でアクセスする。

例えば、球のモデルを100個画面に生成したい場合、球の種類のStorageクラスから頂点情報を読み取り、
球用のStorageクラスから画像情報を読み取り、それをもとにModelクラスを100個生成する。

ファイルから必要なモデルを読み込むのは、シーンファイルをパースするのと同時に行われ、
シーンファイルから指定されたモデルやテクスチャ画像がStorageクラスに存在する場合は、それを参照するようにして、
ない場合は、先ほどのように生成してStorageクラスに格納して、それへの参照を返す。

次に、シーンに必要なModelクラス(モデル、テクスチャ、Animationなどを組み合わせたもの)を保存するには、
それぞれのインスタンスにstringの文字列でアクセスするため、unordered_mapを用いて記録する。
std::unordered_map<std::string,std::shared_ptr<Model>>といった具合に格納する。
モデル、テクスチャ、Animationを格納する流れとしては、パーサーがオブジェクトの名前、仮初のシーンファイルscene.txtでいう
Cube(オブジェクトの名前)を読み取ったら、Modelクラスのインスタンスを作成して、それぞれのトークンを読みとったらset〜()で
セットしていく。

Modelクラスを必要なだけ、生成出来たら、このModelクラスを渡す。この際、Modelクラスを生成して、
Vulkan側が欲しいデータ(オブジェクトの原点からの距離など)を渡すことで、Vulkan側にデータを渡す。
このModelクラスにはVulkan固有の機能である、Descriptorなどを示すidなどを持つ。

Modelクラスを利用したレンダリングは後日記載する

レンダリングが終了したら、Modelクラスはすべて破棄する。

次のフレームの処理に移す。最初のフレームはModelクラスを生成したのちに、すぐにレンダリングしたが、2フレーム目からは、
Sceneクラス内のUpdateFrame関数でModelクラスの処理(Animationによる座標移動など)を終わらせてからレンダリングする。

Animation関数に関する記述は後日。

このようにしてとりあえず、シーンのレンダリングをする。


<FileManagerクラス>

このクラスはインスタンスをstatic変数としてどこでもアクセスできるようにする
シングルトン(fileManagerクラスも同様)


<Storageクラス>
private:

Meshesのポインタを持つマップ

ImageDataのポインタを持つマップ

それぞれのマップにファイルから読み取ったデータの参照を加える関数

public:

マップの持つポインタの所有権を共有する関数

マップの持つポインタの生ポインタを返す関数

それぞれのマップのサイズを返す関数

<Modelクラス>
private:
Storageクラスの持つMeshesクラスのポインタ

Materialクラスのポインタ(インスタンスはModelクラスで生成)

public:

Meshesポインタをセットする関数

ImageDataポインタをセットする関数

Materialポインタをセットする関数

<Materialクラス>
private:
glm::vec3のdiffuseなどの変数を持つ

StorageクラスのImageDataへのポインタを持つ

コンストラクタ：引数として、MeshesとImageDataのポインタを持つ

マテリアルの係数を設定する関数:diffuseなど

マテリアルのテクスチャをセットする関数

マテリアルの係数をそれぞれ返す関数

マテリアルのテクスチャを返す関数

<Sceneクラス>
private:
stringをキーとしてModelクラスのunique_ptrを持つマップ

public:
コンストラクタ：vector<char>にファイルの文字列を入れる

vector<char>の文字列のパースをする関数、トークナイザーなどを利用する

VulkanBaseクラスのModelクラスにModelクラスをセットする関数
(Modelクラスがどういうつのテクスチャなどを参照している場合は、VulkanBaseクラス側で対応する
、なので、実際には、VulkanBaseクラス側のModelクラスを作成する関数にModelクラスを引き渡す関数)

このクラスはシングルトンを使用する
<VulkanBaseクラス>
private:
Vulkanの動作に必要な様々な変数

Modelクラスのunique_ptrを持つvector配列

public:
Modelクラスからデータを読み取り、レンダリングする関数

Modelクラスから呼び出され、Modelクラスを作成する関数、Modelクラスのポインタを引数に持つ

<Modelクラス>
private:

Descriptorの配列から使用するものを指定するIDとなるuint32_t

public

Meshesのポインタを返す関数

Materialのポインタを返す関数

Vulkanでのレンダリングに必要なもの

1.テクスチャを持たないモデルとテクスチャを持つモデルの二つを描く場合は、DescriptorLayoutが二つ必要。
テクスチャの種類の違いによって、レイアウトの数も応じる必要ない。

2.前述の場合、グラフィックスパイプラインが二つ必要。シェーダによってテクスチャ用のdescriptorを引数とするシェーダとそうでないシェーダの二つを利用するため。
この場合でもデプスバッファー関連は、RenderPassの管轄なので、深度テストは行われる。

3.DescriptorLayoutが異なる場合、その数だけのDescriptorPoolが必要

4.モデルのマテリアルなどの各種設定と、それに合わせた、DescriptorSetLayoutとDescriptorPoolを引数に渡して、DescriptorSetを作成する。
なお、これには、テクスチャの違う場合は、それに応じた個数を作らなければならない

5.描画時、まずグラフィックスパイプラインを設定して、頂点、インデックス、DescriptorSetsと指定して、最後に、vkCmd
Indexed()を実行する。


1.に必要なもの
テクスチャ用のDescriptorとUniformBuffer用のDescriptorがいる
テクスチャ用だけでいい
UniformBufferだけでいい

こういう風に、どんな種類のDescriptorLayoutがいるのか調べる

2.に必要なもの
1.で作った分だけのグラフィックスパイプラインが必要。このとき、それぞれのDescriptorLayoutに応じたシェーダ
、を参照する必要がある

3.に必要なもの
作成したDescriptorLayoutの数だけ、DescriptorPoolを作成

4.に必要なもの
モデルが必要とするDescriptorLayoutを指定して、マテリアルの設定やテクスチャなどをお指定して、DescriptorSetsを作る。
よって、これはvkModelにあらかじめ対応するDescriptorLayoutを登録しておいて、それにマテリアル設定を指定していけばいい。
このDescriptorSetsはレイアウトが同じでも、テクスチャなどが異なる場合は個別にDescriptorSetsを作成する必要がある。

5.に必要なもの
vkModelに登録されたDescriptorSetsなどを指定できるようにする必要がある。



1.の実装
VkStorageクラスという、VulkanBase用のStorageクラスを作成し、作成したDescriptorなどをそれに持たせる。
既存のDescriptorLayoutやDescriptorSetsなどは、そこから持ってくる。
DescriptorLayoutの登録などは、Storageクラスなど同じようにする。
vkModelにテクスチャがいるかどうか、UniformBufferがいるかどうかのboolを持たせて、それから、Layoutを作成する。
既存のレイアウトで十分な場合の識別もそれで行う。なお識別はVkStorageクラスで行う。

2.の実装
これは、DescriptorSetLayoutを作成するのと同じ繰り返しでグラフィックスパイプライン作成することにする。

3.の実装
これは単純に、DescriptorSetLayoutのvectorからサイズを求め、それだけDescriptorPoolを作る。

4.の実装
vkModelクラスから指定されたDescriptorSetLayoutを参照して、指定したUniformBufferにモデル行列などをセットする。
という風にしていく。

5.の実装
vkModelからDescriptorSetsのIDを受け取り、VkStorageクラスから指定されたDescriptorSetsを受け取り、以前のように、
レンダリングする。
=======
全体の流れ

setModelsにより、Modelが作られる
↓
render()を実行
↓
いろいろと変える必要があるかをboolで判断(以下初期描写時を想定)
↓
頂点、インデックスバッファーを持たせる
↓
UniformBufferを持たせる
↓
テクスチャデータを持たせる
↓


ディスクリプターレイアウト、ディスクリプタプール、パイプラインレイアウト
これらは、同じグループのモデルで使いまわせる。
これらをStorageに持たせて、Modelはそれの参照を取得することにする。
ディスクリプタレイアウトが決まればプールとパイプラインレイアウトが決まるので、レイアウトを決定するUniformBufferの数などをキーとする。
UniformBufferやテクスチャの有無はビットで判断できるようにする。

特定のモデルの座標の位置を動かす
・コントローラクラスから入力を受け取る
・Modelを継承したPlayerクラスでモデルの移動などを対応する。



ファイルの読み込みにはassimpを使う

GltfModelクラスに必要なもの

メッシュのデータ
テクスチャのデータ
ボーンのデータ


ボーンは参照するボーンのIDとウエイトを頂点構造体が持つ

レンダリング時に、頂点データを編集するため、頂点データの座標変換などはgpuにやらせる
GltfModelはファイルのシーン内に複数のモデルがある場合、メンバ変数としてGltfModelを持つ
通常はModelクラスはそれらをまとめて一つのモデルとして認識する。

Animationクラス
・アニメーションの具体的な行列などはここに記録する
・ここでアニメーションの時間管理をする
・行列などはfileManagerクラスで入力される

具体的には
・アニメーションを再生する場合、ここから行列を取り出す
・Animationクラス単位で時間の管理を行う
・このクラスですべてのボーン行列を算出して、行列の配列をVulkanBaseクラスに渡す
・時間をキーとして、クォータニオンを持つmapを用意する