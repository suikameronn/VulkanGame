// USAGE
//
//    このファイルを参照する必要がある場所にインクルードします。
//    1つのC/C++ファイルで、以下のように記述します。
//        #define STB_TRUETYPE_IMPLEMENTATION
//    このファイルの#includeの前に記述します。これにより、実際の
//    実装がそのC/C++ファイルに展開されます。
//
//    実装を実装を生成するファイルに対してプライベートにするには、
//        #define STBTT_STATIC
//
//    シンプルな3D API（製品に含めるべきではありませんが、ツールやクイックスタートには適しています）
//        stbtt_BakeFontBitmap()           -- テクスチャとして使用するためのフォントをビットマップにベイクします
//        stbtt_GetBakedQuad()              -- 指定された文字の描画クアッドを計算します
//
//    改良された3D API（より製品に適しています）：
//        #include "stb_rect_pack.h"        -- オプションですが、実際には必要です
//        stbtt_PackBegin()
//        stbtt_PackSetOversampling()      -- 小さいフォントの品質を向上させるためのオーバーサンプリングを設定します
//        stbtt_PackFontRanges()           -- パックしてレンダリングします
//        stbtt_PackEnd()
//        stbtt_GetPackedQuad()
//
//    メモリバッファからフォントファイルを「ロード」します（バッファをロードしたままにする必要があります）
//        stbtt_InitFont()
//        stbtt_GetFontOffsetForIndex()     -- TTCフォントコレクションのインデックス処理
//        stbtt_GetNumberOfFonts()          -- TTCフォントコレクションのフォント数
//
//    Unicodeコードポイントをビットマップにレンダリングします
//        stbtt_GetCodepointBitmap()        -- ビットマップを割り当てて返します
//        stbtt_MakeCodepointBitmap()       -- 提供されたビットマップにレンダリングします
//        stbtt_GetCodepointBitmapBox()     -- ビットマップのサイズ
//
//    文字の進み/位置決め
//        stbtt_GetCodepointHMetrics()
//        stbtt_GetFontVMetrics()
//        stbtt_GetFontVMetricsOS2()
//        stbtt_GetCodepointKernAdvance()
//
//    バージョン1.06以降、ラスタライザーは新しい、より高速で一般的に高精度のラスタライザーに置き換えられました。
//    新しいラスタライザーは、アンチエイリアスのピクセルカバレッジをより正確に測定しますが、
//    複数の形状が重なる場合を除きます。この場合、AAピクセルカバレッジを過大評価します。
//    したがって、交差する形状のアンチエイリアスは誤って見える場合があります。
//    これが問題になる場合は、古いラスタライザーを再度有効にすることができます。
//        #define STBTT_RASTERIZER_VERSION 1
//    これにより、約15％の速度低下が発生します。



// 追加ドキュメント
//
//    このブロックコメントの直後に、一連のサンプルプログラムがあります。
//
//    サンプルプログラムの後には、「ヘッダーファイル」セクションがあります。
//    このセクションには、各API関数のドキュメントが含まれています。
//
//    このライブラリを使用するために理解しておくべきいくつかの重要な概念：
//
//        コードポイント
//            文字はUnicodeコードポイントによって定義されます。
//            例：65は大文字のA、231はセディーユ付きの小文字のc、0x7e30はひらがなの「ま」です。
//
//        グリフ
//            視覚的な文字形状（すべてのコードポイントは何らかのグリフとしてレンダリングされます）
//
//        グリフインデックス
//            グリフを表すフォント固有の整数ID
//
//        ベースライン
//            グリフ形状は大文字の底であるベースラインを基準に定義されます。
//            文字はベースラインの上と下の両方に拡張されます。
//
//        現在のポイント
//            画面にテキストを描画するとき、各文字の原点である「現在のポイント」を追跡します。
//            現在のポイントの垂直位置はベースラインです。
//            「ベイクされたフォント」でもこのモデルを使用します。
//
//        垂直フォントメトリクス
//            文字を垂直方向に配置および間隔を空けるために使用されるフォントの垂直特性。
//            stbtt_GetFontVMetricsのドキュメントを参照してください。
//
//        ピクセルまたはポイント単位のフォントサイズ
//            stb_truetypeでフォントサイズを指定するための推奨されるインターフェースは、
//            フォントの垂直範囲がピクセル単位でどれだけの高さになるかを指定することです。
//            それで十分な場合は、次の段落をスキップしてください。
//
//            ほとんどのフォントAPIは代わりに「ポイント」を使用します。
//            これは、フォントサイズを記述するための一般的なタイポグラフィ測定単位であり、
//            1インチあたり72ポイントと定義されています。
//            stb_truetypeは互換性のためにポイントAPIを提供します。
//            ただし、真の「インチ単位」の規則は、
//            異なるモニターがインチあたりのピクセル数が異なるため、コンピューターディスプレイではあまり意味がありません。
//            たとえば、Windowsは伝統的に1インチあたり96ピクセルという規則を使用しており、
//            「インチ」測定がインチと何の関係もなくなり、事実上ポイントを1.333ピクセルと定義しています。
//            さらに、TrueTypeフォントデータは、特定のフォントのグリフをポイントに拡大縮小するための明示的なスケールファクターを提供しますが、
//            著者は、このスケールファクターが非商用フォントではしばしば間違っていることを観察しており、
//            したがって、TrueType仕様に従ってポイントで拡大縮小されたフォントは、実際には一貫性のないサイズになります。





// 詳細な使用方法:
//
//    スケール:
//        フォントの高さをポイントまたはピクセルで選択します。
//        ScaleForPixelHeightまたはScaleForMappingEmToPixelsを呼び出して、
//        他のすべての関数で使用されるスケールファクターSFを計算します。
//
//    ベースライン:
//        テキストが表示されるベースラインとなるy座標を選択する必要があります。
//        GetFontBoundingBoxを呼び出して、すべての文字のベースライン相対の
//        バウンディングボックスを取得します。SF*-y0は、最悪の場合の文字が
//        ベースラインより上に拡張するピクセル単位の距離になります。
//        したがって、文字の上端を画面の上部（y=0）に表示したい場合は、
//        ベースラインをSF*-y0に設定します。
//
//    現在のポイント:
//        最初の文字が表示される現在のポイントを設定します。
//        最初の文字は現在のポイントの左側に拡張する可能性があります。これはフォントに依存します。
//        左端のポイントを現在のポイントとして選択して期待するか、
//        パディングを追加するか、または表示する最初の文字のバウンディングボックスまたは
//        左側ベアリングを確認して、それに基づいて現在のポイントを設定できます。
//
//    文字の表示:
//        文字のバウンディングボックスを計算します。
//        <現在のポイント、ベースライン>を基準とした符号付きの値が含まれます。
//        つまり、x0,y0,x1,y1を返す場合、文字は
//        <現在のポイント+SF*x0, ベースライン+SF*y0>から
//        <現在のポイント+SF*x1, ベースライン+SF*y1>までの矩形に表示する必要があります。
//
//    次の文字に進む:
//        GlyphHMetricsを呼び出し、「現在のポイント += SF * 進み」を計算します。
//
//
// 高度な使用方法
//
//    品質:
//
//    - サブピクセル位置決めを可能にするために、末尾にSubpixelが付いた関数を使用します。
//      フォントはアンチエイリアス処理されており、ヒント処理されていないため、
//      これは品質にとって非常に重要です。（ベイクされたフォントではこれは不可能です。）
//
//    - カーニングがサポートされるようになり、サブピクセルレンダリングをサポートしている場合は、
//      カーニングを使用するとテキストに洗練された外観を与える価値があります。
//
//    パフォーマンス:
//
//    - Unicodeコードポイントをグリフインデックスに変換し、グリフを操作します。
//      これを行わない場合、stb_truetypeはすべての呼び出しで変換を強制的に実行します。
//
//    - メモリ割り当てが多数あります。一時バッファを受け取り、一時バッファから割り当てるように（解放せずに）変更する必要があります。
//      パフォーマンスが大幅に向上するはずです。
//
// 注釈
//
//    システムは、.ttfファイルにある生のデータを変更せずに、補助データ構造を構築せずに使用します。
//    これはリトルエンディアンシステムでは少し非効率ですが（データはビッグエンディアンです）、
//    ビットマップまたはグリフ形状をキャッシュしていると仮定すると、これは大きな問題にはなりません。
//
//    与えられたファイルがどのフォントであるかをプログラムで一般的に決定することは非常に難しいようです。
//    これのためのAPIを提供しますが、お勧めしません。